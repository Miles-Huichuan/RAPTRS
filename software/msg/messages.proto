/*
* Brian R Taylor
* brian.taylor@bolderflight.com
* 
* Copyright (c) 2018 Bolder Flight Systems
* 
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
* and associated documentation files (the "Software"), to deal in the Software without restriction, 
* including without limitation the rights to use, copy, modify, merge, publish, distribute, 
* sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is 
* furnished to do so, subject to the following conditions:
* 
* The above copyright notice and this permission notice shall be included in all copies or 
* substantial portions of the Software.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING 
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
syntax = "proto3";
/*
* Top level message container. Includes a hash to identify the object and a
* payload: either a configuration message or a data message.
*/
message Object {
  fixed64 hash = 1;
  oneof payload {
    ConfigMessage config_msg = 2;
    DataMessage data_msg = 3;
  }
}
/*
* Configuration message definition.
*/
message ConfigMessage {
  oneof payload {
    IntegratedMpu9250Config int_mpu9250_config = 1; // Integrated MPU-9250 config
    IntegratedBme280Config int_bme280_config = 2;   // Integrated BME-280 config
    Mpu9250Config mpu9250_config = 3;               // MPU-9250 config
    Bme280Config bme280_config = 4;                 // BME-280 config
    SbusConfig sbus_config = 5;                     // SBUS config
    uBloxConfig ublox_config = 6;                   // uBlox config
    SwiftConfig swift_config = 7;                   // Swift config
    Ams5915Config ams5915_config = 8;               // AMS-5915 config
    AnalogConfig analog_config = 9;                 // Analog config
    DigitalConfig digital_config = 10;              // Digital config
    VoltageConfig voltage_config = 11;              // Voltage config
  }
}
/*
* Data message definition.
*/
message DataMessage {
  oneof payload {
    Mpu9250Data mpu9250_data = 1;         // MPU-9250 data
    Bme280Data bme280_data = 2;           // BME-280 data
    SbusData sbus_data = 3;               // SBUS data
    uBloxData ublox_data = 4;             // uBlox data
    SwiftData swift_data = 5;             // Swift data
    Ams5915Data ams5915_data = 6;         // AMS-5915 data
    AnalogData analog_data = 7;           // Analog data
    DigitalData digital_data = 8;         // Digital data
    VoltageData voltage_data = 9;         // Voltage data
  }
}
/*
* FMU integrated MPU-9250 configuration. Communication bus (SPI) and CS
* pin are fixed values. Configurable accel range, gyro range, 
* sample rate divider, bandwidth, orientation as a yaw, roll, pitch 
* sequence of rotations, accel bias, mag bias, and mag scale factor.
*/
message IntegratedMpu9250Config {
  enum AccelRange {
    ACCEL_RANGE_2G = 0;
    ACCEL_RANGE_4G = 1;
    ACCEL_RANGE_8G = 2;
    ACCEL_RANGE_16G = 3;
  }
  enum GyroRange {
    GYRO_RANGE_250DPS = 0;
    GYRO_RANGE_500DPS = 1;
    GYRO_RANGE_1000DPS = 2;
    GYRO_RANGE_2000DPS = 3;
  }
  enum Bandwidth {
    DLPF_BANDWIDTH_184HZ = 0;
    DLPF_BANDWIDTH_92HZ = 1;
    DLPF_BANDWIDTH_41HZ = 2;
    DLPF_BANDWIDTH_20HZ = 3;
    DLPF_BANDWIDTH_10HZ = 4;
    DLPF_BANDWIDTH_5HZ = 5;
  }
  string name = 1;                // object name
  AccelRange accel_range = 2;     // accelerometer range
  GyroRange gyro_range = 3;       // gyro range
  Bandwidth bandwidth = 4;        // low pass filter bandwidth
  uint32 srd = 5;                 // sample rate divider
  float rot_yaw_rad = 6;          // yaw rotation
  float rot_roll_rad = 7;         // roll rotation
  float rot_pitch_rad = 8;        // pitch rotation
  float ax_bias_mss = 9;          // ax bias
  float ay_bias_mss = 10;          // ay bias
  float az_bias_mss = 11;         // az bias
  float hx_bias_ut = 12;          // hx bias
  float hy_bias_ut = 13;          // hy bias
  float hz_bias_ut = 14;          // hz bias
  float hx_scale = 15;            // hx scale
  float hy_scale = 16;            // hy scale
  float hz_scale = 17;            // hz scale
}
/*
* FMU integrated BME-280 configuration. Communication bus (SPI) and CS
* pin are fixed values.
*/
message IntegratedBme280Config {
  string name = 1;                // object name
}
/*
* External MPU-9250 configuration. Specify the address of the FMU or Node the
* sensor is connected to, whether it's communicating over SPI (only available
* on the FMU with a fixed CS pin) or I2C, the I2C bus (only one bus available
* on the FMU with two available on the Node), the I2C address (two available),
* accel range, gyro range, sample rate divider, bandwidth, orientation as a
* yaw, roll, pitch sequence of rotations, accel bias, mag bias, and mag
* scale factor.
*/
message Mpu9250Config {
  enum AccelRange {
    ACCEL_RANGE_2G = 0;
    ACCEL_RANGE_4G = 1;
    ACCEL_RANGE_8G = 2;
    ACCEL_RANGE_16G = 3;
  }
  enum GyroRange {
    GYRO_RANGE_250DPS = 0;
    GYRO_RANGE_500DPS = 1;
    GYRO_RANGE_1000DPS = 2;
    GYRO_RANGE_2000DPS = 3;
  }
  enum Bandwidth {
    DLPF_BANDWIDTH_184HZ = 0;
    DLPF_BANDWIDTH_92HZ = 1;
    DLPF_BANDWIDTH_41HZ = 2;
    DLPF_BANDWIDTH_20HZ = 3;
    DLPF_BANDWIDTH_10HZ = 4;
    DLPF_BANDWIDTH_5HZ = 5;
  }
  string name = 1;                // object name
  uint32 bfs_addr = 2;            // bfs addr of component
  bool use_spi = 3;               // 0 = i2c, 1 = spi
  uint32 bus = 4;                 // i2c bus
  uint32 addr = 5;                // i2c addr
  AccelRange  accel_range = 6;    // accelerometer range
  GyroRange  gyro_range = 7;      // gyro range
  Bandwidth bandwidth = 8;        // low pass filter bandwidth
  uint32 srd = 9;                 // sample rate divider
  float rot_yaw_rad = 10;          // yaw rotation
  float rot_roll_rad = 11;        // roll rotation
  float rot_pitch_rad = 12;       // pitch rotation
  float ax_bias_mss = 13;         // ax bias
  float ay_bias_mss = 14;         // ay bias
  float az_bias_mss = 15;         // az bias
  float hx_bias_ut = 16;          // hx bias
  float hy_bias_ut = 17;          // hy bias
  float hz_bias_ut = 18;          // hz bias
  float hx_scale = 19;            // hx scale
  float hy_scale = 20;            // hy scale
  float hz_scale = 21;            // hz scale
}
/*
* External BME-280 configuration. Specify the address of the FMU or Node the
* sensor is connected to, whether it's communicating over SPI (only available
* on the FMU with a fixed CS pin) or I2C, the I2C bus (only one bus available
* on the FMU with two available on the Node), and the I2C address 
* (two available).
*/
message Bme280Config {
  string name = 1;                // object name
  uint32 bfs_addr = 2;            // bfs addr of component
  bool use_spi = 3;               // 0 = i2c, 1 = spi
  uint32 bus = 4;                 // i2c bus
  uint32 addr = 5;                // i2c addr
}
/*
* SBUS receiver configuration, specify the address of the FMU or Node
* the receiver is connected to. The FMU and Nodes have dedicated SBUS
* receiver ports, so the port does not need to be specified.
*/
message SbusConfig {
  string name = 1;                // object name
  uint32 bfs_addr = 2;            // bfs addr of component
}
/*
* uBlox GNSS configuration. Specify the address of the FMU or Node the
* sensor is connected to, the UART port (ports 1 and 2 available on Node, 
* ports 3 and 4 available on FMU), and the baud rate.
*/
message uBloxConfig {
  string name = 1;                // object name
  uint32 bfs_addr = 2;            // bfs addr of component
  uint32 uart = 3;                // uart port
  uint32 baud = 4;                // baud rate
}
/*
* Swift air data configuration. The Swift consists of a static and 
* differential AMS-5915 pressure transducer. Three differential
* transducers are available by request for the Swift depending on 
* the speed range needed. Specify the address of the FMU or Node
* the Swift is connected to, the I2C bus (only one bus available
* on the FMU with two available on the Node), the static and
* differential I2C addresses, and the differential transducer
* type.
*/
message SwiftConfig {
  enum Transducer {
    AMS5915_0005_D = 0;
    AMS5915_0010_D = 1;
    AMS5915_0020_D = 2;
  }
  string name = 1;                // object name
  uint32 bfs_addr = 2;            // bfs addr of component
  uint32 bus = 3;                 // i2c bus
  uint32 static_addr = 4;         // static sensor 12c address
  uint32 diff_addr = 5;           // diff sensor i2c address
  Transducer diff_type = 6;       // diff transducer type
}
/*
* AMS-5915 pressure transduce configuration. Specify the address
* of the FMU or Node the sensor is connected to, the I2C bus 
* (only one bus available on the FMU with two available on the Node),
* the I2C address, and the transducer type.
*/
message Ams5915Config {
  enum Transducer {
    AMS5915_0005_D = 0;
    AMS5915_0010_D = 1;
    AMS5915_0005_D_B = 2;
    AMS5915_0010_D_B = 3;
    AMS5915_0020_D = 4;
    AMS5915_0050_D = 5;
    AMS5915_0100_D = 6;
    AMS5915_0020_D_B = 7;
    AMS5915_0050_D_B = 8;
    AMS5915_0100_D_B = 9;
    AMS5915_0200_D = 10;
    AMS5915_0350_D = 11;
    AMS5915_1000_D = 12;
    AMS5915_2000_D = 13;
    AMS5915_4000_D = 14;
    AMS5915_7000_D = 15;
    AMS5915_10000_D = 16;
    AMS5915_0200_D_B = 17;
    AMS5915_0350_D_B = 18;
    AMS5915_1000_D_B = 19;
    AMS5915_1000_A = 20;
    AMS5915_1200_B = 21;
  }
  string name = 1;                // object name
  uint32 bfs_addr = 2;            // bfs addr of component
  uint32 bus = 3;                 // i2c bus
  uint32 addr = 4;                // i2c addr
  Transducer type = 5;            // transducer type
}
/*
* Analog sensor configuration. Data output is given as both a voltage value
* and a calibrated output (i.e. using a POT to measure control surface
* position). Specify the address of the FMU or Node for the analog input 
* (2 available on the FMU, 8 available on the Node), the channel number for 
* the analog input, and a vector of polynomial coefficients used for
* calibration in descending order.
*/
message AnalogConfig {
  string name = 1;                // object name
  uint32 bfs_addr = 2;            // bfs addr of component
  uint32 channel = 3;             // analog channel number
  repeated float coeff = 4;       // polynomial coefficients
}
/*
* Digital sensor configuration. Data output is given as a boolean value.
* Specify the address of the FMU or Node for the digital input (2 available
* on the FMU, 4 available on the Node), the channel number, and whether a 
* high digital reading should result in a true or false data output.
*/
message DigitalConfig {
  string name = 1;                // object name
  uint32 bfs_addr = 2;            // bfs addr of component
  uint32 channel = 3;             // digital channel number (2 GPIO on FMU, 4 digital pins on Node)
  bool active_high = 4;           // 0 = read high, output 0, 1 = read high, output 1
}
/* 
* Voltage sensor configuration. On the FMU available data includes: input
* voltage (6.5 - 36V), regulated voltage (nominally ~5V), PWM servo voltage
* (0 - 9.9V), and SBUS servo voltage (0 - 9.9V). On the Node, PWM and SBUS
* servo voltages are available. Specify the  FMU or Node address for the
* voltage sensor, and the type (see the listed types).
*/
message VoltageConfig {
  enum Type {
    INPUT = 0;
    REGULATED = 1;
    PWM = 2;
    SBUS = 3;
  }
  string name = 1;                // object name
  uint32 bfs_addr = 2;            // bfs addr of component
  Type type = 3;                  // voltage measurement
}
/*
* MPU-9250 data, includes 3 axis accelerometer, 3 axis gyro, and 
* 3 axis magnetometer data along with die temperature.
*/
message Mpu9250Data {
  uint64 time_us = 1;             // time, microseconds
  float accel_x_mss = 2;          // accel, m/s/s
  float accel_y_mss = 3;
  float accel_z_mss = 4;
  float gyro_x_rads = 5;          // gyro, rad/s
  float gyro_y_rads = 6;
  float gyro_z_rads = 7;
  float mag_x_ut = 8;             // mag, uT
  float mag_y_ut = 9;
  float mag_z_ut = 10;  
  float temp_c = 11;              // temperature, C
}
/*
* BME-280 data, includes static pressure, humidity, and temperature data.
*/
message Bme280Data {
  uint64 time_us = 1;             // time, microseconds
  float press_pa = 2;             // pressure, Pa
  float humidity_rh = 3;          // relative humidity, %
  float temp_c = 4;               // temperature, C  
}
/* 
* SBUS data, includes the time when data was collected. Also includes 
* boolean values for whether a frame was lost, whether the receiver is in 
* failsafe mode, RSSI, and normalized pilot input data. 
*/
message SbusData {
  uint64 time_us = 1;             // time, microseconds
  bool lost_frame = 2;            // 0 = frame received, 1 = frame lost
  bool failsafe_activated = 3;    // 0 = failsafe inactive, 1 = failsafe active
  float RSSI = 4;                 // RSSI (0 - 100)
  repeated float channel = 5;     // SBUS channel data                  
}
/* 
* uBlox data including a boolean value of whether a good fix has
* been acheived, the number of satellites being tracked, the GPS time of week,
* the latitude, longitude, altitude, NED velocity, estimates of horizontal, 
* vertical and speed accuracy, and the position dilution of precision.
*/
message uBloxData {
  uint64 time_us = 1;             // time, microseconds
  bool fix = 2;                   // fix (0 = no fix, 1 = good fix)
  uint32 num_sv = 3;              // number of satellites tracked
  uint64 tow_ms = 4;              // GPS TOW, ms
  double lat_rad = 5;             // latitude, rad
  double lon_rad = 6;             // longitude, rad
  float hmsl_m = 7;               // MSL altitude, m
  float vel_north_ms = 8;         // NED north velocity, m/s
  float vel_east_ms = 9;          // NED east velocity, m/s
  float vel_down_ms = 10;          // NED down velocity, m/s
  float horiz_acc_m = 11;         // horizontal accuracy estimate, m
  float vert_acc_m = 12;          // vertical accuracy estimate, m
  float speed_acc_ms = 13;        // speed accuracy estimate, m/s
  float pdop = 14;                // position dilution of precision
}
/*
* Swift air data, consists of two AMS-5915 sensors: a static pressure
* sensor and a differential pressure sensor.
*/
message SwiftData {
  Ams5915Data static = 1;         // static transducer data
  Ams5915Data differential = 2;   // differential transducer data
}
/*
* Ams5915 data, includes the measured pressure in Pa and the transducer
* die temperature in degrees C.
*/
message Ams5915Data {
  uint64 time_us = 1;             // time, microseconds
  float press_pa = 2;             // pressure, Pa  
  float temp_c = 3;               // temperature, C
}
/* 
* Analog data, includes the measured voltage value and the calibrated value 
* from evaluating calibration polynomial coefficients.
*/
message AnalogData {
  uint64 time_us = 1;             // time, microseconds
  float voltage = 2;              // measured voltage
  float cal_value = 3;            // calibrated value  
}
/* 
* Digital data, including whether the digital pin was measured to be active.
*/
message DigitalData {
  uint64 time_us = 1;             // time, microseconds
  bool active = 2;                // active (true) or not (false)    
}
/* 
* Voltage data including the measured voltage value.
*/
message VoltageData {
  uint64 time_us = 1;             // time, microseconds
  float voltage = 2;              // measured voltage
}
